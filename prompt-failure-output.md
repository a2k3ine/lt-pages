# プロンプト設計ミスの出力（失敗例）

「思考の変化」を重視しすぎた結果、学習ノートとして使えなかった生成結果です。

最初のプロンプトでは「どこで迷ったか・どう考えが変わったか」を重視しすぎて、復習に使える整理されたノートになりませんでした。

このページは、設計を誤ったときにAIがどんな文章を出したかの実例です。

***

🧠 根本の考え方（後で忘れやすいポイント）

- ObsidianのVaultは「Obsidian専用フォルダ」ではなく、ただの普通のフォルダである。VS CodeやCursorからも自由にアクセス・編集できる
- Cursorは「エディタ内にAIを組み込んだ統合環境」であり、生成したコンテンツを直接データとして保存できる点が本質的な強み。単なる「VS Code＋Gemini CLI」ではない
- ObsidianとVS Code/Cursorは競合関係ではなく、「Obsidian＝保管庫、VS Code/Cursor＝ツール作成工房」という役割分担の関係
- CLIは「エンジン」、統合環境は「エンジン＋制御装置＋座席」。同じエンジンでも、統合環境では文脈の取り込み方、編集との一体化、道具箱の揃い方が根本的に異なる
- Gemini CLIがNode.jsが必要な理由は、CLI自体がNode.js（JavaScript）で書かれており、npmパッケージとして配布されているから。実行環境と配布形態がセットである
- Node.js = JavaScriptをPC上で動かす「実行環境」。元々JavaScriptは「ブラウザの中だけ」で動く言語だったが、GoogleのV8エンジンを使ってOS上で直接動くようにしたのがNode.js。つまり、JavaScriptをバックグラウンドの汎用スクリプト言語として使えるようにする基盤
- npm = Node.jsに付属するパッケージマネージャ（配布・管理の仕組み）。Pythonのpip、Linuxのaptみたいなもの。配布形態の決定要因は、その言語で書かれていればその言語のマネージャで配布するのが自然、想定ユーザーの環境（Web開発者ならNode.jsが入っている）、管理のしやすさなど
- MarkdownがAIに向いている理由：構造がシンプルで規則的、プレーンテキストで余計な情報がない。AIにとって重要なのは「内容（テキスト）＋構造」であり、装飾は不要
- トークンとはAIが処理する「文字の最小単位」。Markdownは余計な装飾を省いてテキスト構造だけ残せるため、トークン効率が高い

🔁 混乱 → 理解の変化（Before → After）

Before：
- Cursorを「VS Code＋Gemini CLIみたいな感じ」と理解し、既存ツールの組み合わせとして捉えていた
- ObsidianとVS Codeが競合関係にあると考え、どちらが必要かを悩んでいた
- CLIとCursorが「同じことができるはず」と思い、なぜ同じことができないのか混乱していた
- My-vaultがObsidian専用フォルダのような気がして、VS Codeで共有できるか不安だった
- Gemini CLIを使うために「なぜNode.jsが必要なのか」という根本的な疑問を持っていた。npmとNode.jsの関係が分からなかった。Node.jsが何者か、npmとは何か、なぜnpmで配布されているのか、配布形態の決定要因が何なのか、理解が浅かった
- Markdownに変換するとカラーやスペースなどの装飾情報がどうなるのか、不安だった
- トークンとは何か、なぜMarkdownがトークン効率が良いのか、理解が浅かった

After：
- Cursorは「生成と編集が一体化した統合環境」であり、ローカル保存や直接ファイル生成が可能な点で設計思想が根本的に異なることを理解した
- ObsidianとVS Code/Cursorは役割分担の関係であり、目的に応じて使い分けるものだと理解した
- CLIは「エンジン」、Cursorは「統合環境」であり、同じエンジンでも文脈の取り込み方、編集との一体化、保守のしやすさが大きく変わることを理解した
- My-vaultはただの普通のフォルダであり、Obsidian、VS Code、Cursor、Pythonスクリプト、すべてと同時に共有・連携できることを理解した
- Gemini CLIがnpmパッケージとして配布されているため、Node.jsが必要。Node.jsはJavaScriptをブラウザ外で動かす実行環境（V8エンジンベース）であり、npmはそのパッケージマネージャであることを理解した。配布形態の決定要因（親和性、想定ユーザーの環境、管理のしやすさ）も理解できた
- Markdownに変換すると装飾情報（カラー、スペース指定など）は失われるが、構造（見出し、リスト、階層）は残る。AIにとって重要なのは構造と内容であり、装飾は不要であることを理解した
- トークンはAIが処理する最小単位であり、Markdownは余計な装飾を省いてテキスト構造だけ残せるため、トークン効率が高いことを理解した

Trigger（転換点）：
- 「Cursorを使う場合」と「ChatGPT/Geminiなどのクラウド型LLMを使う場合」の違いを情報整理の観点で比較されたとき、保存の一手間という違いが明確になった
- 「Obsidian＝保管庫、VS Code/Cursor＝ツール作成工房」という比喩で役割分担が腑に落ちた
- 「CLIはエンジン、Cursorは統合環境」という説明で、なぜ同じことができないのかという疑問が解けた
- 「ObsidianのVaultはただの普通のフォルダ」という説明で、VS CodeやCursorとの共有への不安が解消された
- 「Gemini CLIはnpmパッケージとして配布されている」「Node.jsはJavaScriptをブラウザ外で動かす実行環境（V8エンジンベース）」「npmはNode.jsのパッケージマネージャ」という一連の説明で、実行環境と配布形態の関係が理解できた。さらに、自分で整理した「配布形態の決定要因（親和性、想定ユーザー、管理のしやすさ）」により、技術的な依存関係の本質を深く理解できた
- 「AIにとって大事なのは内容（テキスト）＋構造。人間向け装飾（色・余白・フォント指定）は不要」という説明で、Markdown変換時の情報の扱いが明確になった
- 「トークン＝AIが処理する文字の最小単位」「Markdown効率が高い理由＝余計な装飾を省いてテキスト構造だけ残せるから」という説明で、トークンとMarkdownの関係が理解できた

💡 腑に落ちた瞬間（理解が深まった決定的ポイント）

- Cursorは「生成＝編集履歴＝ローカルファイル」という一体化により、Obsidian Vaultに直書き・追記するような運用が可能になる点
- 「生成と保存は分離」しているGemini/ChatGPTと違い、Cursorでは生成物がそのままファイルとして保存されるため、一手間が省ける点
- 「CLIは基本的に入力→出力なので、選択範囲だけ修正、差分適用、複数ファイルを文脈にまとめるといったIDE的な機能は自作スクリプトで補う必要がある」という限界の明確化
- ObsidianのVaultは普通のフォルダであり、VS Code、Cursor、Pythonスクリプト、すべてと同時に共有できるという理解。.obsidianフォルダも設定ファイルが入っているだけなので問題ない
- Gemini CLIがNode.js製（JavaScriptで書かれている）CLIツールであり、開発者や利用者はWeb/クラウド系に慣れている人が多いため、npmでの配布が自然という説明
- Node.jsがPCに入っている人は、過去にWeb開発、フロントエンド開発、CLIツールや自動化、Bot開発、Electronアプリなどの開発をしていた可能性が高いという理解
- 配布形態の決定要因を自分で整理したことで、「その言語で書かれていればその言語のマネージャで配布する」「想定ユーザーの環境に合わせる」「管理のしやすさを考慮する」というエコシステムの考え方が理解できた瞬間
- 「AIにとって大事なのは内容（テキスト）＋構造。人間向け装飾（色・余白・フォント指定）は不要」という説明で、AIとの連携における本質が明確になった
- Markdownに変換すると装飾情報は失われるが、構造（見出し、リスト、階層）は残る。Markdownは「意味の構造だけ残して、見た目の装飾は基本的に削ぎ落とす」という思想のフォーマットであること
- HTMLからMarkdownへの削減率が99%なのに対し、PDFからMarkdownへの削減率が70%なのは、HTMLはタグだらけで冗長、PDFは抽出後は文字比率が高めだからという理解

🎛 私の学習・思考のクセ（パターン）

1. **「既存概念の組み合わせ」として理解しようとする傾向**
   - 新しいツールや概念を既存のものの組み合わせとして捉えがち（例：「CursorはVS Code＋Gemini CLIみたいな感じ？」）
   - これにより初期理解が浅くなりがちで、本質的な違いを見落としやすい

2. **「同じことができるはず」という前提で考えがち**
   - 異なるツールや環境でも「同じことができるはず」と考え、違いを理解するために何度も質問を重ねる
   - この前提を捨て、「なぜ違うのか」という問いから始める必要がある

3. **技術的な依存関係を「なぜ必要か」という根本から理解しようとする粘り強さ**
   - Node.jsが必要な理由を、単に「必要だから」ではなく、実行環境と配布形態の関係、配布形態の決定要因まで掘り下げて理解しようとする
   - 自分の理解を言葉で整理し直すことで、さらに深く理解を定着させようとする傾向がある
   - この粘り強さが理解を深める原動力になっている

4. **装飾や見た目に関する情報の扱いに対する不安を明確にしようとする傾向**
   - Markdown変換時に装飾情報がどうなるか、情報が失われないかという不安を、明確な説明を求めることで解消しようとする

5. **フォルダやファイルの共有可能性について確認を求める傾向**
   - My-vaultをObsidianとVS Codeで共有できるか、Pythonスクリプトをコピーしても大丈夫かなど、運用上の安全性を確認してから進めようとする

6. **比較と対比を通じて理解を深める方法**
   - 複数の選択肢を比較検討しながら、それぞれの特徴や役割分担を明確にしようとする
   - この方法は有効だが、時には「どちらが必要か」ではなく「どのように役割分担するか」を考える視点が必要

🧍‍♂️ 将来の自分へのヒント

- **新しいツールや概念を理解するときは、設計思想や本質的な違いから始める**
  - 「既存の概念の組み合わせ」として考えず、まずはそのツールの設計思想や他のツールとの根本的な違いを確認する

- **「同じことができるはず」という前提を捨て、「なぜ違うのか」という問いから始める**
  - 異なるツールが存在する理由には、それぞれの設計思想や役割分担がある。違いを前提として理解を深める

- **技術的な依存関係を理解するときは、実行環境と配布形態の関係を意識する**
  - ツールが必要とする環境は、そのツールがどの言語で書かれているか、どのように配布されているかと密接に関連している

- **フォルダやファイルの共有可能性については、それが「普通のファイル・フォルダ」かどうかを確認する**
  - 独自形式のデータベースでない限り、多くのツールからアクセス可能であることが多い

- **AIとの連携においては、AIにとって必要な情報（内容と構造）と不要な情報（装飾）を区別する**
  - 構造は残し、装飾は落とすという視点が重要

- **役割分担を理解するときは、「どちらが必要か」ではなく「どのように役割分担するか」を考える**
  - ツール間の競合関係ではなく、協力関係として捉える視点が重要

- **理解が浅いときは、比喩や例え話を活用して、感覚的な理解から言語化への転換を図る**
  - 「エンジンと統合環境」「保管庫と工房」のような比喩は、抽象的な概念を理解する上で有効

---

💾 保存パス（Markdown の末尾にそのまま追記する）

下書き保存（まず置く場所）:
00_inbox/text_clean/chatlog_2025-11-17_obsidian_cursor_draft.md

確定版（内容確認後に移す）:
02_external/chat_notes/chatlog_2025-11-17_obsidian_cursor.md
